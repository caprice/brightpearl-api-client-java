<!DOCTYPE html>
<html>
<head>
    <title>Brightpearl API Client</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="css/prism.css" type="text/css">
    <link rel="stylesheet" href="css/screen.css" type="text/css" media="screen and (min-device-width: 1000px)">
    <link rel="stylesheet" href="css/mobile.css" type="text/css" media="screen and (max-device-width: 999px)">
    <link rel="stylesheet" href="css/print.css" type="text/css" media="print">
    <script type="text/javascript" src="js/jquery-2.0.3.min.js"></script>
    <script type="text/javascript" src="js/bootstrap.min.js"></script>
    <meta name="author" content="David Morrissey &copy; 2014">
    <meta name="robots" content="index,follow">
    <meta name="viewport" content="initial-scale=1">
</head>
<body>
<div id="title-panel">
    <div id="title-panel-inner">
        <h1>Brightpearl Client</h1>
        <h2>A simple Java client library for the Brightpearl API</h2>

        <ul class="contact">
            <li>
                <a href="https://github.com/davemorrissey/brightpearl-api-client-java" target="_blank">View on GitHub <i class="fa fa-github fa-fixed-width"></i></a>
            </li>
        </ul>
        <ul class="navigation" id="navigation">
            <li><a href="#start">Getting started</a></li>
            <li><a href="#auth">Authentication</a></li>
            <li><a href="#request">Making requests</a></li>
            <li><a href="#search">Making searches</a></li>
            <li><a href="#multimessage">Multi messages</a></li>
            <li><a href="#error">Error handling</a></li>
            <li><a href="#ratelimit">Rate limiting</a></li>
            <li><a href="#configuration">Configuration</a></li>
            <li>&nbsp;</li>
            <li><a href="#versions">Version history</a></li>
            <li><a href="#license">License</a></li>
            <li><a href="#">Javadoc</a></li>
        </ul>
    </div>
</div>

<div id="content-panel">
<div id="content-panel-inner">
<a name="start" id="start"></a>
<div class="header">
    <h3>Getting Started</h3>
</div>
<div class="section">
    <div class="section-content">
<div class="alert alert-info">
    <strong>TL;DR</strong> If you'd like to see a complete working example, see the <a href="https://github.com/davemorrissey/brightpearl-api-client-java/blob/master/src/test/java/uk/co/visalia/brightpearl/apiclient/CodeSamples.java">CodeSamples</a> class.
</div>
<p>
    Before getting started with this client library, we recommend you read the tutorials and guides
    on the Brightpearl website so you're familiar with how their API works.
</p>
<ul>
    <li>Find your datacenter from the <a href="http://www.brightpearl.com/developer/latest/concept/uri-syntax.html">URI Syntax</a> page.</li>
    <li>Read the <a href="http://www.brightpearl.com/developer/latest/concept/api-fundamentals.html">Brightpearl API fundamentals</a>.</li>
    <li>Understand the <a href="http://www.brightpearl.com/developer/latest/concept/response-structure.html">structure of JSON responses</a>.</li>
    <li>Learn about <a href="http://www.brightpearl.com/developer/latest/tutorial/working-with-resource-search.html">resource searches</a>.</li>
</ul>
<h4>Add the library to your project</h4>
<div class="alert alert-danger">
    We're still setting up releases and Sonatype hosting. They'll be ready in a few days.
</div>
<p>
    Builds are published to the <a href="http://central.sonatype.org/" target="_blank">Sonatype Central Repository</a>.
    If you're using Maven, add this dependency: <code>uk.co.visalia.brightpearl:api-client:1.0.0</code>.
</p>
<p>
    The library has only two dependencies - GSON and Apache HttpComponents - to keep it as portable as possible.
    It can even be used on Android. GSON is used for serialising JSON requests and deserialising responses, and
    can be added to Maven projects as a normal dependency, and to Android projects as a library. Apache HttpComponents
    provides the HTTP client. You can provide your own implementation of the <code title="uk.co.visalia.brightpearl.apiclient.http.Client">Client</code> class to remove
    the dependency on HttpComponents - we'll provide an alternative for Android soon.
</p>
<p>
    Here are the Maven dependencies you'll need for a default setup:
</p>
<pre><code class="language-markup">
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
    &lt;version&gt;4.3.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
    &lt;artifactId&gt;gson&lt;/artifactId&gt;
    &lt;version&gt;2.2.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;uk.co.visalia.brightpearl&lt;/groupId&gt;
    &lt;artifactId&gt;api-client&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4>Create a client</h4>
<p>
    For most users, the default configuration of <code>BrighpearlApiClient</code> will be suitable. You can configure
    your own HTTP client, rate limiter implementation and GSON factory if you need to - see the <a href="#configuration">configuration</a>
    section for details.
</p>
<p>
    In the meantime, this is all you need to do to create a <code>BrightpearlApiClient</code> instance.
</p>
<pre><code class="language-java">
BrightpearlApiClient client = BrightpearlApiClientFactory.brightpearlApiClient().build();
</code></pre>
</div>
</div>
<a name="auth" id="auth"></a>
<div class="header">
    <h3>Authentication</h3>
</div>
<div class="section">
    <div class="section-content">
<h4>Public Apps</h4>
<div class="alert alert-info">
    This section is for Brightpearl registered developers. If you're a Brightpearl customer building an app for
    your own account, see the next section.
</div>
<p>
    We assume you know the account code and datacentre of the Brightpearl customer account you wish to connect to, and
    for system apps, you also have an account token for the account. Read Brightpearl's documentation to find out how to
    get this information.
</p>
<h5>1) Create app identity</h5>
<p>
    The <code>PublicAppIdentity</code> object identifies your app. It can be reused for all API sessions; you only need
    to create it once regardless of how many Brightpearl accounts you are working with. You don't need to supply your
    developer secret if you will sign the account tokens yourself, or if you are only using staff authentication.
</p>
<div class="alert alert-danger">Never include your developer secret in a distributed binary e.g. a mobile or desktop app!</div>
<pre><code class="language-java">
PublicAppIdentity appIdentity = PublicAppIdentity.create(
        "codemonkeys",
        "YmIwYWFlNjBjZGRmY2UxMw==",
        "quickinvoice");
</code></pre>
<h5>2) Create authorisation object</h5>
<p>
    There are two types of authorisation, system and staff, corresponding to Brightpearl's app types. System authorisation
    requires an account token which you must get from Brightpearl when the customer installs your app. Staff authentication
    requires a staff token, which you can request using the staff member's login details.
</p>
<pre><code class="language-java">
// Define customer account.
Account account = new Account(Datacenter.EU1, "visalia");

// SYSTEM AUTH
// Create system authentication object. As long as you included your developer
// secret in the app identity, you can supply signed or unsigned account tokens.
PublicAppAuthorisation systemAuthorisation = PublicAppAuthorisation.system(
        appIdentity,
        new Account(Datacenter.EU1, "visalia"),
        "53f5d01f-4795-40df-acc0-d15b4c8e91fc");

// STAFF AUTH
// Define staff credentials.
UserCredentials credentials = new UserCredentials("sarah@visalia.co.uk", "sesame");

// Request a staff token using provided credentials.
String staffToken = client.fetchStaffToken(
        appIdentity,
        account,
        credentials);

// Create an authentication using this token. Your developer secret is not required.
PublicAppAuthorisation appAuthorisation = PublicAppAuthorisation.staff(
        appIdentity,
        account,
        staffToken);
</code></pre>

You can now use the authorisation object with your <code>BrightpearlApiClient</code> instance. See <a href="#request">making requests</a>
for more information.

<h4>Private Apps</h4>
<div class="alert alert-info">
    This section is for Brightpearl customers creating an app for their own account. If you're a registered developer,
    please see the section above.
</div>
<h5>1) Create app identity</h5>
<p>
    The <code>PrivateAppIdentity</code> object identifies your app and account.
</p>
<pre><code class="language-java">
// Create your app identity (valid for all sessions).
PrivateAppIdentity appIdentity = PrivateAppIdentity.create(
        new Account(Datacenter.EU1, "visalia"),
        "visalia_quickinvoice");
</code></pre>
<h5>2) Create authorisation object</h5>
<p>
    There are two types of authorisation, system and staff, corresponding to Brightpearl's app types. System authorisation
    requires the account token that was generated when you created your private app. Staff authentication requires a staff
    token, which you can request using the staff member's login details.
</p>
<pre><code class="language-java">

// SYSTEM AUTH
// Create system authentication object for your app and account. Use the token
// shown in the Brightpearl private apps page.
PrivateAppAuthorisation appAuthorisation = PrivateAppAuthorisation.system(
        appIdentity,
        "53f5d01f-4795-40df-acc0-d15b4c8e91fc");

// STAFF AUTH
// Define staff credentials.
UserCredentials credentials = new UserCredentials("sarah@visalia.co.uk", "sesame");

// Request a staff token using these credentials.
String staffToken = client.fetchStaffToken(
        appIdentity,
        credentials);

// Create an authentication using this token.
PrivateAppAuthorisation appAuthorisation = PrivateAppAuthorisation.staff(
        appIdentity,
        staffToken);
</code></pre>

You can now use the authorisation object with your <code>BrightpearlApiClient</code> instance. See <a href="#request">making requests</a>
for more information.

<h4>Legacy authentication</h4>
<div class="alert alert-info">
    Brightpearl's legacy method of authenticating API calls will be removed in the future. We recommend registering as a
    developer and using the new methods above.
</div>
<p>
    The <code>BrightpearlLegacyApiSession</code> class is provided for developers still using the old method of
    authentication. Each instance of this class is specific to the Brightpearl account it was created for.
</p>
<p>
    This class provides the same interface as <code>BrightpearlApiClient</code> for making API requests, and fetches
    auth tokens for you. By default it also handles renewal of authentication tokens automatically when they
    expire after a period of inactivity. Authentication exceptions will only be thrown if a new token cannot be fetched,
    usually because the staff member has changed their password.
</p>
<p>
    The factory class will create a session instance wrapping with a default <code>BrightpearlApiClient</code> instance,
    which you can override by providing your own if you need.
</p>
<pre><code class="language-java">
Account account = new Account(Datacenter.EU1, "visalia");
UserCredentials credentials = new UserCredentials("sarah@visalia.co.uk", "sesame");
BrightpearlLegacyApiSession session = BrightpearlLegacyApiSessionFactory.newApiSessionFactory()
    .withAccount(account)
    .withUserCredentials(credentials)
    .newApiSession();
</code></pre>
<p>
    At this point, the session will not be authenticated; an authentication token
    will be requested when you make your first request or you can request one
    manually.
</p>

    </div>
</div>
<a name="request"></a>
<div class="header">
    <h3>Making requests</h3>
</div>
<div class="section">
    <div class="section-content">
<p>
    You can use request builders to create requests to any resource URI, passing your own objects for
    serialisation in the request body and your own type references for deserialisation of the response.
    Here are some examples.
</p>
<pre><code class="language-java">
// Fetch a product by ID
ServiceReadRequest&lt;List&lt;Product&gt;&gt; productListRequest =
    ServiceReadRequestBuilder.&lt;List&lt;CustomProduct&gt;&gt;newGetRequest(
        ServiceName.PRODUCT,
        "/product/1007",
        new TypeToken&lt;List&lt;Product&gt;&gt;() { }.getType())
    .build();
List&lt;Product&gt; products = client.get(appAuthorisation, productListRequest);

// Add a new brand
Brand brand = new Brand();
brand.setName("Apple");
brand.setDescription("Consumer electronics");

ServiceWriteRequest&lt;Integer&gt; brandPostRequest =
    ServiceWriteRequestBuilder.newPostRequest(
        ServiceName.PRODUCT,
        "/brand",
        brand,
        Integer.class)
    .build();
Integer brandId = client.execute(appAuthorisation, brandPostRequest);
</code></pre>
<p>
    To create a request, use the static methods on <code>ServiceReadRequestBuilder</code> or <code>ServiceWriteRequestBuilder</code>
    supplying the service name, path and expected response type. You can supply your own instance of the <code>ServiceName</code>
    class if you are using a service not already listed.
</p>
<p>
    To support generic type responses, use the GSON <code>TypeToken</code> class as illustrated in the example above. The
    builder methods that accept <code>Type</code> instances to define the response type cannot use the <code>Type</code>
    to infer the generic type so you must declare it.
</p>
<p>
    The response type should be a class that matches the JSON response expected from Brightpearl. Alternatively,
    you can declare the expected response type to be GSON's <code>JsonElement</code> class and extract the parts of the
    response you need.
</p>

<h4>Field names</h4>
<p>
    If you want to name a field differently in your custom object to how it appears in Brightpearl's JSON
    responses, use GSON's <code>@SerializedName</code> annotation to declare the column name for a field.
</p>
<pre><code class="language-java">
@SerializedName("name")
private String productName;
</code></pre>
    </div>
</div>
<a name="search"></a>
<div class="header">
    <h3>Making searches</h3>
</div>
<div class="section">
    <div class="section-content">
<p>
    Use the <code>ServiceSearchRequestBuilder</code> class to create a search request.
</p>
<p>

</p>
<pre><code class="language-java">
// Search for products by name
ServiceSearchRequest&lt;ProductSearch&gt; searchRequest =
    ServiceSearchRequestBuilder.newSearchRequest(
        ServiceName.PRODUCT,
        "/product-search",
        ProductSearch.class)
    .withAddedFilter("productName", "iPod")
    .build();
SearchResults&lt;ProductSearch&gt; results = client.search(appAuthorisation, searchRequest);
</code></pre>

<h4>Field names</h4>
<p>
	Fields in each result array are matched to the result class using the column name index
	included in each search response. For example, if column 0 is named <code>productId</code>,
	the value at index 0 of each result array will be copied to the <code>productId</code> field
	of a result object.
</p>
<p>
	If the column name is not suitable for a Java field name, use GSON's <code>@SerializedName</code>
	annotation to declare the column name for a field.
</p>
<pre><code class="language-java">
@SerializedName("ISBN")
private String isbn;
</code></pre>

<h4>Reference data extraction</h4>
<p>
	Reference data is included in some search APIs to provide additional data for search
	results, either to avoid repeating the same data on every result, or to support the
	inclusion of complex types that cannot be included in result arrays. For example,
	the <a href="http://www.brightpearl.com/developer/latest/product/product/search.html">product search</a>
	response includes a list of category IDs for each product.
</p>
<p>
	This library supports automatic copying of reference data into search results, by looking
	up the key contained in each result array from the corresponding reference data map. To
	use this feature in your own custom types, annotate the fields with <code>ReferenceKey</code>
	and <code>ReferenceField</code>.
</p>
<p>
	We'll use a cut-down response from the <a href="http://www.brightpearl.com/developer/latest/warehouse/goods-in-note/search.html">goods in note search</a>
	API to illustrate this. This response includes a productId column which can be used to look
	up product names, and a warehouseId column from which we can get the warehouse name.
</p>
<pre><code class="language-javascript">
{ response: {
    metaData: {
        columns: [
            { name: "productId" },
            { name: "warehouseId" }
        ]
    },
    results: [
        [1008, 2],
        [1015, 3]
    ]
}, reference: {
    warehouseNames: {
        2: "Main warehouse",
        3: "Edinburgh warehouse"
    },
    productNames: {
        1008: "PPL Book 1: Air Law",
        1015: "David Clark H10-13.4 Headset"
    }
}}
</code></pre>
<p>
	In our custom type, we annotate the two ID fields with <code>@ReferenceKey</code> to indicate they are
	keys to reference data maps, and the two name fields with <code>@ReferenceField</code> to indicate
	they should receive value from the reference data.
</p>
<pre><code class="language-java">
public class GoodsInNoteSearch {

    @ReferenceKey("productNames")
    private Integer productId;

    @ReferenceKey("warehouseNames")
    private Integer warehouseId;

    @ReferenceField("productNames")
    private String productName;

    @ReferenceField("warehouseNames")
    private String warehouseName;

    // Getters and setters

 }
</code></pre>
<p>
	The <code>@ReferenceKey</code> annotation accepts an array of reference data map names so that
	the same field can be used as a key for more than one map.
</p>
    </div>
</div>
<a name="multimessage"></a>
<div class="header">
    <h3>Multimessages</h3>
</div>
<div class="section">
    <div class="section-content">
    <p>
	To fully understand this page we recommend you read <a href="http://www.brightpearl.com/developer/latest/concept/multi-message.html">Brightpearl's introduction to the multi-message API</a>.
</p>
<h4>Introduction</h4>
<p>
    Using the multi-message API reduces latency on slow connections, and each multi-message counts
    as only one request against the request cap, regardless of how many individual messages are
    included. This library provides full support for creating multi-messages, and a simple method
    for checking the results.
</p>
<p>
	Multi-message requests are built by adding individual requests to a <code>MultiRequestBuilder</code>
	instance. Each individual request (or message) is a POST, PUT or DELETE request created using the
	same request builder classes used to send a request directly. The response from Brightpearl is
	returned as a <code>MultiResponse</code>, from which responses to individual requests can be
	extracted.
</p>
<p>
    This is a simple example with no error checking.
</p>
<pre><code class="language-java">
ServiceWriteRequest<Integer> request1 = ServiceWriteRequestBuilder
        .newPostRequest(ServiceName.PRODUCT, "/brand", brand1, Integer.class);
ServiceWriteRequest<Integer> request2 = ServiceWriteRequestBuilder
        .newPostRequest(ServiceName.PRODUCT, "/brand", brand2, Integer.class);

MultiRequestBuilder request = MultiRequestBuilder.newMultiRequest()
        .withAddedRequest(request1)
        .withAddedRequest(request2);

MultiResponse multiResponse = client.execute(appAuthorisation, request);
Integer brandId1 = multiResponse.getServiceResponse(request1).getResponse();
Integer brandId2 = multiResponse.getServiceResponse(request2).getResponse();
</code></pre>

<h4>Error handling</h4>
<p>
	If a request to the multi-message API fails with an HTTP transport error, the method will throw a
	<code>BrightpearlHttpException</code>. This is not a guarantee that the individual requests have
	not been executed because the error may have occurred after Brightpearl accepted the batch for processing.
</p>
<p>
 	When an error status is received from the Brightpearl multi-message API, this indicates none of the
 	requests have been processed, and an exception from the <code>uk.co.visalia.brightpearl.apiclient.exception</code>
 	package will be thrown.
</p>
<p>
	If Brightpearl returns a 200 or 207 response, the response is parsed into a <code>MultiResponse</code>,
	containing a list of the RUIDs of requests that Brightpearl did not process, and individual responses
	(including the status code and any error messages) for each request that was processed.
</p>
<p>
	The following code is an example of multi-message handling with error checking.
</p>
<pre><code class="language-java">
ServiceWriteRequest<Integer> request1 = ServiceWriteRequestBuilder
        .newPostRequest(ServiceName.PRODUCT, "/brand", brand1, Integer.class);
ServiceWriteRequest<Integer> request2 = ServiceWriteRequestBuilder
        .newPostRequest(ServiceName.PRODUCT, "/brand", brand2, Integer.class);

MultiRequestBuilder request = MultiRequestBuilder.newMultiRequest()
        .withAddedRequest(request1)
        .withAddedRequest(request2)
        .withOnFailOption(OnFailOption.CONTINUE)
        .withProcessingMode(ProcessingMode.PARALLEL);

try {
    MultiResponse multiResponse = session.execute(request);

    if (!multiResponse.getUnprocessedRequestRuids().isEmpty()) {
        // Handle messages that were not processed
    }

    ServiceResponse&lt;Integer&gt; response1 = multiResponse.getServiceResponse(request1);
    if (response1 == null) {
        // Brand 1 request was not processed
    } else if (response1.isSuccess()) {
        // Brand 1 was created
        Integer brand1Id = response1.getResponse();
    } else {
        // Brand 1 request failed - in most cases a collection of errors will give more details
        List&lt;ServiceError&gt; brand1Errors = response1.getErrors();

        // Calling getResponse() when isSuccess() returns true will throw the exception received
        try {
            response1.getResponse();
        } catch (BrightpearlClientException e) {
            // Handle response failure
        }
    }
} catch (BrightpearlHttpException e) {
    // Transport error
} catch (BrightpearlClientException e) {
    // An exception corresponding to the response code returned by BP
}
</code></pre>

<h4>Large batches</h4>
<p>
	Brightpearl's multi-message API supports between 2 and 10 messages per batch. To simplify the
	use of this API, the multi-message methods in this library can handle any number of requests
	and will split them into batches of 10 or send individual requests direct to the target API.
</p>
<p>
	This involves returning a simulated <code>MultiResponse</code> that looks similar to how Brightpearl's
	response would have looked if the requests could be sent as one batch. When HTTP transport
	errors occur, it isn't possible to do this accurately, so you may prefer to manually batch your
	requests.
</p>
    </div>
</div>
<a name="error"></a>
<div class="header">
    <h3>Error handling</h3>
</div>
<div class="section">
    <div class="section-content">
        <p>
            The <code>get()</code>, <code>search()</code> and <code>execute()</code> methods of
            <code>BrightpearlApiSession</code> and <code>BrightpearlApiClient</code> only return
            normally if they successfully executed the request and parsed the result into the
            expected type. For all error conditions, subclasses of <code>BrightpearlClientException</code>
            are thrown.
        </p>
        <p>
            Some of these exceptions are handled slightly differently for multi-message requests.
            Please see the <a href="#multimessage">multi-message guide</a> and the API documentation
            for <code>BrightpearlApiClient</code> for details.
        </p>
        <dl>
            <dt>BrightpearlHttpException</dt>
            <dd>
                Indicates an HTTP transport error during the request to Brightpearl or an unexpected response
                format - either an empty body, badly formatted JSON, or JSON that does not match the expected response type
                declared by the request. The <code>clientErrorCode</code> field provides the reason. Note
                that if you provide your own implementation of <code>Client</code>, it should throw this
                exception in the event of an HTTP error. This exception is NOT used when any non-zero response
                code is received from the API - see <code>BrightpearlServiceException</code>.
            </dd>
            <dt>BrightpearlUnavailableException</dt>
            <dd>
                When a 503 response is received from Brightpearl, but the response body does not indicate
                the request cap has been reached, this exception is thrown. It indicates the account is
                suspended or temporarily unavailable, or Brightpearl is performing maintenance.
            </dd>
            <dt>BrightpearlRequestCapException</dt>
            <dd>
                Used when a 503 response is received from Brightpearl with a response body that indicates
                the request cap was reached. The request may be retried later.
            </dd>
            <dt>BrightpearlServiceException</dt>
            <dd>
                Thrown when the Brightpearl API returns a collection of error messages in the response,
                regardless of the status code. The status code and error messages are included in the
                exception.
            </dd>
            <dt>BrightpearlAuthException</dt>
            <dd>
                Thrown when Brightpearl returns a 401 response, indicating the auth token used is not
                valid. If you are using <code>BrightpearlApiSession</code> with automatic re-authentication
                enabled, it will catch this exception and attempt to re-authenticate, but it can still
                throw this exception if the attempt fails.
            </dd>
            <dt>BrightpearlClientException</dt>
            <dd>
                The superclass exception is used for errors that have occurred within the client library
                itself, and not as a result of a response from Brightpearl. For example, automatic
                re-authentication blocks execution of requests by other threads, and a timeout in those threads waiting for the
                token will cause this exception.
            </dd>
        </dl>
    </div>
</div>
    <a name="ratelimit"></a>
    <div class="header">
        <h3>Rate limiting</h3>
    </div>
    <div class="section">
        <div class="section-content">
            <p>
                Brightpearl allows 200 API requests per minute per account. Once this limit is reached, Brightpearl
                returns 503 responses with a specific message in the body, and this library catches this error and
                throws a <code>BrightpearlRequestCapException</code>. It is guaranteed that the request has not
                been executed by Brightpearl under these circumstances, so you can wait and repeat it later.
            </p>
            <p>
                In applications that expect constant high load or short bursts of intense activity, it may be preferable
                to actively avoid reaching the request cap rather than routinely catching the request cap exception and
                attempting recovery.
            </p>
            <h4>Efficiency</h4>
            <p>
                Many applications will not need to make 200 API requests per minute, and single threaded applications
                may not achieve this rate. For applications that do need to make many requests to single Brightpearl
                accounts, it may be possible to avoid reaching the request cap by using requests efficiently.
            </p>
            <p>
                In summary, the techniques for avoiding the request cap are:
            </p>
            <ul>
                <li>Use ID sets on GET requests to fetch many objects at once</li>
                <li>Cache GET responses</li>
                <li>Batch POST, PUT and DELETE requests using the multi-message API</li>
            </ul>
            <h4>Client side throttling</h4>
            <p>
                To help you avoid reaching the request cap, we have provided the <code>RateLimiter</code> interface.
                The implementation of this interface will be called before every request is sent to Brightpearl,
                when each response is received containing the headers <code>brightpearl-requests-remaining</code>
                and <code>brightpearl-next-throttle-period</code>, and whenever a request cap error is received.
            </p>
            <p>
                We have provided two implementations of this interface. <code>NoOpRateLimiter</code> does nothing
                in any method, and allows an unlimited rate of requests. <code>ConstantWaitRateLimiter</code>
                ensures that no two requests are sent within 300ms of each other, so that no more than 200 can be
                sent within one minute. The latter is quite basic and not suited to applications that may need to
                send bursts of fewer than 200 requests in well under one minute, as it will unnecessarily delay
                them. In an application with hundreds of threads attempting to send requests at well over 200 per
                minute, it may block some threads for excessively long periods.
            </p>
            <p>
                You can use your own implementation of <code>RateLimiter</code> to throttle requests using the
                strategy of your choice, or simply reject requests by throwing a <code>RuntimeException</code>.
                See the <a href="#configuration">configuration</a> section for details.
            </p>
            <h4>Distributed environments</h4>
            <p>
                If multiple servers will be simutaneously making requests to a single Brightpearl account, the
                request cap for that account is shared between them. Although <code>ConstantWaitRateLimiter</code>
                can be configured with a longer minimum period between requests to allow each server one half
                or one third of the request cap, this approach is not recommended.
            </p>
            <p>
                A custom implementation of <code>RateLimiter</code> could be used to share state between the
                servers (for example, via Hazelcast) to ensure the request cap is not reached.
            </p>
            <h4>Further reading</h4>
            <ul>
                <li><a href="http://www.brightpearl.com/developer/latest/concept/request-throttling.html">Brightpearl: Request throttling</a></li>
            </ul>
        </div>
    </div>
    <a name="configuration"></a>
    <div class="header">
        <h3>Configuration</h3>
    </div>
    <div class="section">
        <div class="section-content">
            <p>
    Defaults are available for all the configuration options exception for account and authentication
    details. These defaults are:
</p>
<ul>
    <li>
        HTTP client implementation using Apache HttpClient 4, with a <code>PoolingClientConnectionManager</code>
        allowing 10 concurrent connections per route and 20 total. See the contant fields section in the
        API docs for HttpClient4ClientFactory.
    </li>
    <li>
        GSON configured with a type adapter for <code>java.util.Calendar</code>. Calendar is used in
        favour of <code>java.util.Date</code> for its timezone support.
    </li>
    <li>
        No rate limiting or request cap error recovery.
    </li>
    <li>
        No response caching.
    </li>
    <li>
        Automatic re-authentication disabled in <code>BrightpearlApiSession</code> instances.
    </li>
</ul>
<h4>Configuration options</h4>
<table class="table table-bordered">
    <tr>
        <th colspan="2">BrightpearlAPIClientFactory</th>
    </tr>
    <tr>
        <td>clientFactory</td>
        <td>
            Configures the client with a custom HTTP client factory implementation that implements
            the <code>ClientFactory</code> interface. This may be the included <code>HttpClient4ClientFactory</code>
            with your preferred connection settings, or an entirely different implementation using
            another HTTP library. See below for configuration options of the HttpClient4 implementation.
        </td>
    </tr>
    <tr>
        <td>rateLimiter</td>
        <td>
            By default no rate limiting is applied to requests, and you may reach the request cap of
            200 per minute during busy periods. An implementation of <code>RateLimiter</code> may be
            provided to delay requests under high load, to avoid reaching the limit. The included
            implementation <code>ConstantWaitRateLimiter</code> ensures a minimum time between requests
            (300ms).
        </td>
    </tr>
    <tr>
        <td>gson</td>
        <td>
            The default configuration of GSON includes support for serialising and deserialising
            <code>java.util.Calendar</code> instances, as used by the domain objects included with
            this library. If you are using your own domain objects, for example with Joda dates,
            use this option to provide a GSON instance configured appropriately.
        </td>
    </tr>
    <tr>
        <th colspan="2">BrightpearlLegacyApiSessionFactory (Legacy authentication)</th>
    </tr>
    <tr>
        <td>account</td>
        <td>
            Provide an instance of <code>Account</code> containing the datacenter and an account code
            of a Brightpearl customer account. The datacenter can be found on Brightpearl's <a href="http://www.brightpearl.com/developer/latest/concept/uri-syntax.html">URI Syntax</a> page.
            Required for all sessions.
        </td>
    </tr>
    <tr>
        <td>userCredentials</td>
        <td>
            Provide an instance of <code>UserCredentials</code> with the email address and password
            of an API-enabled user account.
            Required when creating an API session that is able to generate an auth token for itself.
            If you are generating auth tokens externally to create pre-authenticated sessions this
            is not required.
        </td>
    </tr>
    <tr>
        <td>expiredAuthTokenStrategy</td>
        <td>
            Configures the session to either throw all expired auth token exceptions,
            or to catch these exceptions and attempt to use the configured credentials to create a new
            auth token. Enum values are <code>FAIL</code> and <code>REAUTHENTICATE</code>. The REAUTHENTICATE option cannot be
            used with sessions created using a pre-fetched token.
        </td>
    </tr>
    <tr>
        <td>brightpearlApiClient</td>
        <td>
            Sessions are account-specific wrappers for a <code>BrightpearlApiClient</code> instance.
            This method allows you to provide a client instance with custom configuration, as described
            above.
        </td>
    </tr>
    <tr>
        <th colspan="2">HttpClient4ClientFactoryBuilder</th>
    </tr>
    <tr>
        <td>connectionManagerTimeoutMs</td>
        <td>Maximum time in milliseconds to wait for a pooled connection to become free.</td>
    </tr>
    <tr>
        <td>connectionTimeoutMs</td>
        <td>
            Determines the timeout in milliseconds until a connection is established. A timeout value of zero is interpreted as an infinite timeout.
        </td>
    </tr>
    <tr>
        <td>socketTimeoutMs</td>
        <td>
            Defines the socket timeout in milliseconds, a maximum period of inactivity between two consecutive data packets. A timeout value of zero is interpreted as an infinite timeout.
        </td>
    </tr>
    <tr>
        <td>allowRedirects</td>
        <td>Defines whether redirects should be followed. Redirects are not expected from the Brightpearl API, and are not followed by default.</td>
    </tr>
    <tr>
        <td>maxConnections</td>
        <td>Defines the maximum number of connections allowed for all routes.</td>
    </tr>
    <tr>
        <td>maxConnectionsPerRoute</td>
        <td>Defines the maximum number of connections allowed per route (target server, or Brightpearl datacenter). This is not a limit per Brightpearl account.</td>
    </tr>
</table>

<h4>Example configuration</h4>
<p>
    Here's an example of how to configure a client with customised HTTP client settings and GSON configuration, and a request rate limiter.
</p>
<pre><code class="language-java">
ClientFactory clientFactory = HttpClient4ClientFactoryBuilder
        .httpClient4ClientFactory()
        .withConnectionManagerTimeoutMs(10000)
        .withConnectionTimeoutMs(15000)
        .withSocketTimeoutMs(5000)
        .withAllowRedirects(false)
        .withMaxConnections(60)
        .withMaxConnectionsPerRoute(20)
        .build();

BrightpearlApiClient client = BrightpearlApiClientFactory
        .brightpearlApiClient()
        .withClientFactory(clientFactory)
        .withRateLimiter(new ConstantWaitRateLimiter(100, 1, TimeUnit.MINUTES))
        .withGson(new GsonBuilder().create())
        .build();

// LEGACY AUTH ONLY
BrightpearlLegacyApiSession session = BrightpearlLegacyApiSessionFactory
        .newApiSessionFactory()
        .withBrightpearlApiClient(client)
        .withExpiredAuthTokenStrategy(ExpiredAuthTokenStrategy.FAIL)
        .withAccount(new Account(Datacenter.EU1, "visalia"))
        .withUserCredentials(new UserCredentials("sarah@visalia.co.uk", "sesame"))
        .newApiSession();
</code></pre>
        </div>
    </div>
    <a name="versions"></a>
    <div class="header">
        <h3>Version history</h3>
    </div>
    <div class="section">
        <div class="section-content">
            <p>
                First release build coming soon.
            </p>
        </div>
    </div>
    <a name="license"></a>
    <div class="header">
        <h3>License</h3>
    </div>
    <div class="section">
        <div class="section-content">
            This library is copyright 2014 David Morrissey, and licensed under the Apache License, Version 2.0.
        </div>
    </div>
</div>




</div>
<script src="js/prism.js"></script>
</body>
</html>